"""
Plan entity: Structured decomposition of analysis intent into executable subtasks.

Schema: plan_id, request_id, subtasks, total_estimated_seconds, reasoning
"""

from typing import List
from pydantic import BaseModel, Field
import uuid
from datetime import datetime


class Subtask(BaseModel):
    """Individual subtask in analysis plan."""
    
    subtask_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    description: str = Field(..., description="Natural language description of subtask")
    tool_name: str = Field(..., description="Tool to execute (sql, pandas, plot, profile)")
    estimated_seconds: float = Field(default=5.0, ge=0)
    dependencies: List[str] = Field(default_factory=list, description="Subtask IDs that must complete first")


class Plan(BaseModel):
    """
    Analysis plan: Ordered decomposition of user intent into tool calls.
    
    Generated by Planner phase, consumed by Actor phase.
    """
    
    plan_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    request_id: str = Field(..., description="Parent analysis request ID")
    subtasks: List[Subtask] = Field(..., description="Ordered list of subtasks")
    total_estimated_seconds: float = Field(..., ge=0, description="Sum of subtask estimates")
    reasoning: str = Field(..., description="LLM's reasoning for this decomposition")
    created_at: datetime = Field(default_factory=datetime.utcnow)
    
    class Config:
        json_schema_extra = {
            "example": {
                "plan_id": "550e8400-e29b-41d4-a716-446655440000",
                "request_id": "req-001",
                "subtasks": [
                    {
                        "subtask_id": "sub-001",
                        "description": "Query sales table for Q1 2021 Arizona data",
                        "tool_name": "sql",
                        "estimated_seconds": 3.0,
                        "dependencies": []
                    },
                    {
                        "subtask_id": "sub-002",
                        "description": "Aggregate sales by month",
                        "tool_name": "pandas",
                        "estimated_seconds": 1.0,
                        "dependencies": ["sub-001"]
                    },
                    {
                        "subtask_id": "sub-003",
                        "description": "Plot monthly sales trend line chart",
                        "tool_name": "plot",
                        "estimated_seconds": 2.0,
                        "dependencies": ["sub-002"]
                    }
                ],
                "total_estimated_seconds": 6.0,
                "reasoning": "Decompose into SQL retrieval → Pandas aggregation → Matplotlib visualization"
            }
        }
    
    def validate_dag(self) -> bool:
        """Verify subtasks form valid directed acyclic graph (no cycles)."""
        visited = set()
        rec_stack = set()
        
        def has_cycle(subtask_id: str) -> bool:
            visited.add(subtask_id)
            rec_stack.add(subtask_id)
            
            # Find subtask by ID
            subtask = next((s for s in self.subtasks if s.subtask_id == subtask_id), None)
            if not subtask:
                return False
            
            # Check dependencies
            for dep_id in subtask.dependencies:
                if dep_id not in visited:
                    if has_cycle(dep_id):
                        return True
                elif dep_id in rec_stack:
                    return True  # Cycle detected
            
            rec_stack.remove(subtask_id)
            return False
        
        # Check all subtasks
        for subtask in self.subtasks:
            if subtask.subtask_id not in visited:
                if has_cycle(subtask.subtask_id):
                    return False  # Cycle found
        
        return True  # No cycles, valid DAG